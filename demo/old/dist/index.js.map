{
  "version": 3,
  "sources": ["../../src/components/uni/tools.js", "../../src/components/uni/consts.js", "../../src/components/uni/Table.js", "../../src/components/sync/tools.js", "../../src/components/sync/interfaces/DB.js", "../../src/components/sync/privates/Chop.js", "../../src/components/sync/privates/Bundle.js", "../../src/components/sync/privates/Transactions.js", "../../src/components/sync/interfaces/Rows.js", "../../src/components/sync/privates/Step.js", "../../src/components/sync/interfaces/Wrap.js", "../../src/components/sync/interfaces/Row.js", "../../src/components/sync/interfaces/Cols.js", "../../src/components/sync/traits.js", "../../src/components/sync/interfaces/Col.js", "../../src/components/uni/formats.js", "../../src/components/v3/effects/_bits.js", "../../src/components/v3/effects/afterRemove.js", "../../src/components/v3/effects/afterReset.js", "../../src/components/v3/effects/afterUpdate.js", "../../src/components/v3/effects/eventHandlers.js", "../../src/components/v3/effects/afterAdd.js", "../../src/components/v3/class/Chop.js", "../../src/components/v3/meta.js", "../../src/components/v3/class/Record.js", "../../src/components/v3/class/Push.js", "../../src/components/v3/class/Columns.js", "../../src/components/v3/class/Exceptions.js", "../../src/components/v3/class/DB.js", "../../src/index.js", "../src/index.js"],
  "sourcesContent": ["\r\nexport const nref = (tableName, colName, filter)=>{\r\n    return {\r\n        isVirtual:true,\r\n        isTrusted:true,\r\n        ref:tableName,\r\n        separator:\"; \",\r\n        scope:tableName,\r\n        formula:(row, cache)=>row.refs(tableName, colName, filter, cache)\r\n    }\r\n};\r\n\r\nexport const timestamps = (doerRef, doerFormula, alternative=false)=>({\r\n    [\"updated\"+(alternative ? \"\" : \"_at\")]: { type: \"datetime\", formula: _ => new Date() },\r\n    updater: { ref:doerRef, formula:doerFormula },\r\n    [\"created\"+(alternative ? \"\" : \"_at\")]: { type: \"datetime\", init: _ => new Date(), isReadonly: true },\r\n    creator: { ref:doerRef, init:doerFormula, isReadonly:true }\r\n});\r\n\r\nexport const breachSelector = (selector, onOne, onMany)=>{\r\n    let alias, path;\r\n\r\n    const isArray = Array.isArray(selector);\r\n    if (!isArray) { [path, selector] = String.jet.bite(selector, \".\"); }\r\n\r\n    if (path) { [alias, path] = String.jet.bite(path, \":\"); }\r\n    else if (!isArray && !selector.includes(\",\")) { [alias, selector] = String.jet.bite(selector, \":\"); }\r\n    else { return onMany(isArray ? selector : selector.split(\",\")); }\r\n\r\n    return onOne(alias, path, selector);\r\n}", "import jet from \"@randajan/jet-core\";\r\n\r\nconst { solid, cached } = jet.prop;\r\n\r\nexport const vault = new WeakMap();\r\n\r\nconst eventsWhen = [\"before\", \"after\"];\r\nexport const events = cached.all({}, {}, {\r\n    primitive:_=>[].concat(\r\n        ...eventsWhen.map(w=>[\"set\", \"update\", \"remove\"].map(c=>[w, c, w+String.jet.capitalize(c)]))\r\n    ),\r\n    extra:_=>[].concat(\r\n        ...eventsWhen.map(w=>[\"change\", \"save\"].map(c=>[w, c, w+String.jet.capitalize(c)]))\r\n    )\r\n});\r\n\r\n\r\n\r\nexport const formatKey = (key, def)=>key != null ? String(key) : def;\r\nexport const numberPositive = (num, def=0)=>num == null ? def : Math.max(0, Number.jet.to(num));\r\nexport const functionOrNull = val=>val == null ? undefined : Function.jet.to(val);\r\nexport const boolDef = (val, def)=>val == null ? def : !!val;\r\n\r\n\r\nconst _sortBy = (colName, descending=false, list=[])=>{\r\n    const _sb = (colName, descending)=>_sortBy(colName, descending, list);\r\n    solid(_sb, \"list\", list);\r\n    list.push([colName, Boolean.jet.to(descending)]);\r\n    return _sb;\r\n}\r\n\r\nexport const sortBy = (colName, descending=false)=>_sortBy(colName, descending);\r\n\r\nexport const fcePass = v=>v;\r\nexport const fceNone = ()=>{};\r\nexport const fceTrue = _=>true;", "import jet from \"@randajan/jet-core\";\r\nimport { events } from \"./consts\";\r\n\r\nconst { solid, cached, virtual } = jet.prop;\r\n\r\nexport class Table {\r\n\r\n  static is(any) { return any instanceof Table; }\r\n\r\n  constructor(db, name, config={}) {\r\n    const { stream, bundle, Rows, Cols, onRows } = config;\r\n    const _p = cached({}, {}, \"stream\", _=>Object.jet.to(stream, this)); //cache even config object\r\n    _p.lastChange = Date.now();\r\n\r\n    solid(this, \"db\", db, false);\r\n    solid(this, \"name\", name);\r\n\r\n    cached.all(this, _p, {\r\n      cols:_=>{\r\n        const cols = new Cols(this, _p.stream.cols);\r\n        bundle.on(\"afterReset\", _=>cols.reset(), { once:true });\r\n        return cols;\r\n      },\r\n      rows:_=>{\r\n        const rows = new Rows(this, _p.stream.rows);\r\n\r\n        for (const [when, action, name] of events.extra) {\r\n          const cleanUp = rows.on(name, (standardAction, rowLive)=>bundle.run(name, [standardAction, rowLive]));\r\n          rows.on(\"afterReset\", cleanUp, { once:true });\r\n        }\r\n\r\n        bundle.on(\"afterReset\", _=>rows.reset(), { once:true });\r\n        rows.on(\"afterChange\", _=>_p.lastChange = Date.now());\r\n        return rows;\r\n      }\r\n    }, false);\r\n\r\n    virtual.all(this, {\r\n      state:_=>this.rows.state,\r\n      isLoading:_=>this.rows.isLoading,\r\n      lastChange:_=>_p.lastChange\r\n    });\r\n\r\n  }\r\n\r\n  msg(text) { return this.db.msg(text, this.name); }\r\n\r\n  eval(selector, opt={}) {\r\n    return this.rows.eval(selector, opt);\r\n  }\r\n\r\n  getKey() {\r\n    return this.name;\r\n  }\r\n\r\n  toString() {\r\n    return this.name || \"\";\r\n  }\r\n\r\n  toJSON() {\r\n    return this;\r\n  }\r\n\r\n\r\n}\r\n  ", "import jet from \"@randajan/jet-core\";\r\nimport { breachSelector } from \"../uni/tools\";\r\n\r\nexport const reductor = (getList, callback, init) => {\r\n    return row => {\r\n        let val = init;\r\n        for (const x of getList(row)) { val = callback(val, x); }\r\n        return val;\r\n    }\r\n}\r\n\r\nexport const summary = (colList, colSum) => reductor(row => row(colList), (total, child) => total += child(colSum), 0);\r\n\r\nexport const remap = (arr, onItem, byKey = false) => {\r\n    const rk = byKey ? {} : null;\r\n    const rl = arr.map(item => onItem(item, rk));\r\n    return rk || rl;\r\n}\r\n\r\n\r\n\r\nexport const evaluate = (base, selector, opt, to, forceAlias)=>{\r\n    if (!base?.get) { return; }\r\n\r\n    const { byKey, throwError } = opt;\r\n\r\n    return breachSelector(selector, \r\n        (alias, path, selector)=>{\r\n            let res;\r\n            if (!path) { res = base.get(selector, throwError !== false); }\r\n            else if (path !== \"*\") {\r\n                const ref = base.get(path, throwError !== false);\r\n                if (!ref?.eval) { return; }\r\n                res = ref.eval(selector, opt);\r\n            } else {\r\n                if (!base.getList) { return; }\r\n                const arr = base.getList();\r\n                return remap(arr, (item, rk) => {\r\n                    const r = item?.eval(selector, opt);\r\n                    return rk ? rk[item] = r : r;\r\n                }, byKey);\r\n            }\r\n\r\n            if (!byKey) { return res; }\r\n            const key = forceAlias || alias || path || selector;\r\n            if (!to) { return { [key]: res }; }\r\n            if (to.hasOwnProperty(key)) { throw Error(`selector collision at ${key}, please use alias`); }\r\n            to[key] = res;\r\n            return to;\r\n        },\r\n        arr=>remap(arr, (item, rk) => evaluate(base, item, opt, to || rk), byKey)\r\n    );\r\n\r\n}", "import jet from \"@randajan/jet-core\";\r\nimport { each } from \"@randajan/jet-core/eachSync\";\r\nimport { Table } from \"../../uni/Table\";\r\nimport { Chop } from \"../privates/Chop\";\r\nimport { Rows } from \"./Rows\";\r\nimport { Cols } from \"./Cols\";\r\nimport { numberPositive, vault } from \"../../uni/consts\";\r\n\r\nconst { solid, virtual } = jet.prop;\r\n\r\nexport class DB extends Chop {\r\n\r\n    constructor(name, stream, config={}) {\r\n        \r\n        const { displayDefault, decimalDefault, maxAge, maxAgeError } = config;\r\n        super(name, {\r\n            stream,\r\n            loader: (self, bundle, tables) => {\r\n                each(tables, (stream, ctx) =>{ bundle.set(new Table(this, ctx.key, { bundle, stream, Rows, Cols })); });\r\n            },\r\n            childName: \"table\",\r\n            defaultContext: \"all\",\r\n            maxAge,\r\n            maxAgeError\r\n        });\r\n\r\n        const _p = vault.get(this);\r\n        _p.lastChange = Date.now();\r\n\r\n        this.on(\"afterChange\", _=>_p.lastChange = Date.now());\r\n\r\n        virtual(this, \"lastChange\", _=>_p.lastChange);\r\n        solid(this, \"displayDefault\", numberPositive(displayDefault));\r\n        solid(this, \"decimalDefault\", numberPositive(decimalDefault, 2));\r\n        \r\n    }\r\n\r\n    exist(name, throwError = false) {\r\n        return super.exist(name, undefined, throwError);\r\n    }\r\n\r\n    get(name, throwError = true) {\r\n        return super.get(name, undefined, throwError);\r\n    }\r\n\r\n    count(throwError = true) {\r\n        return super.count(undefined, throwError);\r\n    }\r\n\r\n    getList(throwError = true) {\r\n        return super.getList(undefined, throwError);\r\n    }\r\n\r\n    getIndex(throwError = true) {\r\n        return super.getIndex(undefined, throwError);\r\n    }\r\n\r\n}", "import jet from \"@randajan/jet-core\";\r\nimport { formatKey, vault } from \"../../uni/consts\";\r\nimport { Bundle } from \"./Bundle\";\r\nimport { Transactions } from \"./Transactions\";\r\nimport { evaluate } from \"../tools\";\r\n\r\nconst { solid, virtual } = jet.prop;\r\n\r\nexport class Chop extends jet.types.Plex {\r\n\r\n  constructor(name, config = {}) {\r\n    const { stream, loader, parent, childName, getContext, defaultContext, maxAge, maxAgeError, extra } = Object.jet.to(config);    \r\n    super((...args) => this.get(...args));\r\n\r\n    const _p = {\r\n      isLoaded:false,\r\n      loader,\r\n      stream: jet.isRunnable(stream) ? stream : _ => stream,\r\n      transactions:new Transactions(_=>{\r\n        if (!this.maxAgeError) { return; }\r\n        clearTimeout(_p.intError);\r\n        _p.intError = setTimeout(_=>this.reset(), this.maxAgeError);\r\n      }),\r\n      bundle:new Bundle(\r\n        parent?.name,\r\n        name,\r\n        childName,\r\n        getContext,\r\n        defaultContext\r\n      ),\r\n      subs:{}\r\n    }\r\n    vault.set(this, _p);\r\n\r\n    solid.all(this, {\r\n      parent,\r\n      maxAge: Math.max(0, Number.jet.to(maxAge)),\r\n      maxAgeError: Math.max(0, Number.jet.to(maxAgeError)),\r\n      extra: solid.all({}, Object.jet.to(extra))\r\n    }, false);\r\n\r\n    virtual.all(this, {\r\n      state:_=>(!_p.isLoaded && _p.transactions.state === \"ready\") ? \"concept\" : _p.transactions.state,\r\n      name:_=>_p.bundle.name,\r\n      fullName:_=>_p.bundle.fullName,\r\n      childName:_=>_p.bundle.childName,\r\n      isLoading:_=>_p.transactions.state === \"loading\"\r\n    });\r\n\r\n    _p.bundle.on(\"afterReset\", _=>{\r\n      clearTimeout(_p.intError);\r\n      clearTimeout(_p.intAge);\r\n      _p.isLoaded = false;\r\n      _p.transactions.reset();\r\n    });\r\n\r\n    _p.bundle.on(\"afterLoad\", _=>{\r\n      if (this.maxAge) {\r\n        clearTimeout(_p.intAge);\r\n        _p.intAge = setTimeout(_=>this.reset(), this.maxAge);\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n  on(event, callback, opt={}) {\r\n    return vault.get(this).bundle.on(event, callback, opt);\r\n  }\r\n\r\n  msg(text, key, context) {\r\n    return vault.get(this).bundle.msg(text, key, context);\r\n  }\r\n\r\n  exist(key, context, throwError = false) {\r\n    this.untilLoaded();\r\n    return vault.get(this).bundle.exist(key, context, throwError);\r\n  }\r\n\r\n  get(key, context, throwError = true) {\r\n    this.untilLoaded();\r\n    return vault.get(this).bundle.get(key, context, throwError);\r\n  }\r\n\r\n  eval(selector, opt={}) {\r\n    return evaluate(this, selector, opt);\r\n  }\r\n\r\n  count(context, throwError=false) {\r\n    this.untilLoaded();\r\n    return vault.get(this).bundle.getData(context, throwError).list.length;\r\n  }\r\n\r\n  getList(context, throwError=false) {\r\n    this.untilLoaded();\r\n    return [...vault.get(this).bundle.getData(context, throwError).list];\r\n  }\r\n\r\n  getIndex(context, throwError=false) {\r\n    this.untilLoaded();\r\n    return {...vault.get(this).bundle.getData(context, throwError).index};\r\n  }\r\n\r\n  getContextList() {\r\n    this.untilLoaded();\r\n    return Object.keys(vault.get(this).bundle.data);\r\n  }\r\n\r\n  map(callback, opt={}) {\r\n    this.untilLoaded();\r\n    return vault.get(this).bundle.map(callback, opt);\r\n  }\r\n\r\n  find(checker, opt={}) {\r\n    this.untilLoaded();\r\n    return vault.get(this).bundle.find(checker, opt);\r\n  }\r\n\r\n  reset(throwError=true) {\r\n    return vault.get(this).bundle.reset(throwError);\r\n  }\r\n\r\n  untilLoaded(throwError = true) {\r\n    const _p = vault.get(this);\r\n    if (_p.isLoaded) { return true; }\r\n\r\n    const { state, last } = _p.transactions;\r\n    if (state === \"error\") { return throwError ? last : false; }\r\n    if (state === \"loading\") { return last; }\r\n\r\n    return _p.transactions.execute(\"loading\", _=>{\r\n      if (_p.isLoaded) { return; }\r\n      _p.bundle.run(\"beforeLoad\", [this]);\r\n      const data = _p.stream(this);\r\n      _p.loader(this, _p.bundle, data);\r\n      _p.isLoaded = true;\r\n      _p.bundle.run(\"afterLoad\", [this]);\r\n    }, { stopOnError:false });\r\n  }\r\n\r\n  withUntilLoaded(execute) {\r\n    return (...args) => {\r\n      this.untilLoaded();\r\n      return execute(...args);\r\n    }\r\n  }\r\n\r\n  addChop(name, config={}) {\r\n    const subs = vault.get(this).subs; //sub chops\r\n    const { useCache, throwError, getContext, defaultContext, loader, extra } = config;\r\n\r\n    name = formatKey(name);\r\n\r\n    if (useCache !== false && subs[name]) {\r\n      if (throwError !== false) { throw Error(this.msg(`chop '${name}' allready exist`)); }\r\n      return subs[name];\r\n    }\r\n\r\n    const sub = new Chop(name, {\r\n      parent:this,\r\n      childName:this.childName,\r\n      maxAge:0,\r\n      maxAgeError:this.maxAgeError,\r\n      getContext,\r\n      defaultContext,\r\n      loader: (chop, bundle) =>{\r\n        this.map(child =>bundle.set(child));\r\n        chop.on(\"afterReset\", this.on(\"afterSet\", child=>bundle.set(child)), { once:true });\r\n        chop.on(\"afterReset\", this.on(\"afterRemove\", child=>bundle.remove(child)), { once:true });\r\n        this.on(\"afterReset\", _=>chop.reset(), { once:true });\r\n        if (loader) { loader(chop, bundle); }\r\n      },\r\n      extra\r\n    });\r\n\r\n    return (useCache !== false) ? subs[name] = sub : sub;\r\n  }\r\n\r\n  getChop(name, throwError=true) {\r\n    const subs = vault.get(this).subs; //sub chops\r\n    if (subs[name]) { return subs[name]; }\r\n    if (throwError) { throw Error(this.msg(`chop '${name}' doesn't exist`)); }\r\n  }\r\n\r\n}", "import jet from \"@randajan/jet-core\";\r\nimport * as _ from \"@randajan/jet-core/eachSync\";\r\nimport { formatKey } from \"../../uni/consts\";\r\n\r\nconst { solid, virtual } = jet.prop;\r\n\r\nexport class Bundle {\r\n\r\n  constructor(parentName, name, childName, getContext, def) {\r\n\r\n    name = formatKey(name, \"Bundle\");\r\n\r\n    solid.all(this, {\r\n      name,\r\n      fullName:(parentName && name) ? (parentName + \".\" + name) : parentName ? parentName : name ? name : \"\",\r\n      childName:formatKey(childName, \"key\"),\r\n      data:{},\r\n      handlers: {},\r\n      getContext: jet.isRunnable(getContext) ? getContext : _=>null,\r\n      def:formatKey(def, \"undefined\")\r\n    });\r\n\r\n    if (!this.name) { throw Error(this.msg(\"critical error - missing name\")); }\r\n\r\n  }\r\n\r\n  msg(text, key, context) {\r\n    const { fullName, childName, def } = this;\r\n    key = formatKey(key);\r\n    context = formatKey(context, def);\r\n    let msg = fullName || \"\";\r\n    if (context !== def) { msg += ` context('${context}')`; }\r\n    if (key) { msg += ` ${childName}('${key}')`; }\r\n    if (text) { msg += \" \"+text; }\r\n    return msg.trim();\r\n  }\r\n\r\n  getData(context, throwError=true, autoCreate=false) {\r\n    const { data, def } = this;\r\n    context = formatKey(context, def);\r\n    if (data[context]) { return data[context]; }\r\n    if (autoCreate || context === def) { return data[context] = { context, index:{}, list:[] }; }\r\n    if (throwError) { throw Error(this.msg(`not found`, undefined, context)); }\r\n    return { context, index:{}, list:[] }\r\n  };\r\n\r\n  validateKey(key, action=\"validateKey\", throwError=true) {\r\n    if (key = key = formatKey(key)) { return key; }\r\n    if (throwError) { throw Error(this.msg(`${action}(...) failed - key undefined`));}\r\n  }\r\n\r\n  on(event, callback, opt={}) {\r\n    if (!jet.isRunnable(callback)) { throw Error(this.msg(`on(...) require callback`)); }\r\n    const { once, bufferMs, maxQueueMs, maxQueueSize } = opt;\r\n    const { handlers } = this;\r\n    const list = (handlers[event] || (handlers[event] = []));\r\n\r\n    let remove;\r\n    let cb = once ? (...args)=>{ callback(...args); remove(); } : callback;\r\n    cb = bufferMs ? jet.buffer(cb, bufferMs, maxQueueMs, maxQueueSize) : cb;\r\n    \r\n    if (event.startsWith(\"before\")) { list.push(cb); } else { list.unshift(cb); }\r\n\r\n    return remove = _ => {\r\n      const id = list.indexOf(cb);\r\n      if (id >= 0) { list.splice(id, 1); }\r\n      return callback;\r\n    }\r\n  }\r\n\r\n  run(event, args=[], opt={}) {\r\n    const throwError = opt.throwError !== false;\r\n    const handlers = this.handlers[event];\r\n    if (!handlers?.length) { return true; }\r\n    const isBefore = event.startsWith(\"before\");\r\n\r\n    for (let i=handlers.length-1; i>=0; i--) {\r\n      const cb = handlers[i];\r\n      if (!cb) { continue; }\r\n      try { cb(...args, opt); } catch(err) {\r\n        if (isBefore && throwError) { throw err; }\r\n        else if (isBefore) { return false; }\r\n        else if (throwError) { console.warn(this.msg(err?.message || \"unknown error\"), err?.stack); }\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n  reset(throwError=true) {\r\n    const opt = { throwError };\r\n    if (!this.run(\"beforeReset\", [], opt)) { return false; }\r\n    for (let i in this.data) { delete this.data[i]; }\r\n    return this.run(\"afterReset\", [], opt);\r\n  }\r\n\r\n  _set(context, key, child, opt={}, afterEffect) {\r\n    const { context:ctx, index, list } = this.getData(context, opt.throwError, true);\r\n    \r\n    if (index.hasOwnProperty(key)) {\r\n      if (opt.throwError !== false) { throw Error(this.msg(`set(...) failed - duplicate`, key, ctx)); }\r\n      return false;\r\n    }\r\n\r\n    if (!(this.run(\"beforeSet\", [child, ctx], opt))) { return false; }\r\n    \r\n    list.push(index[key] = child);\r\n\r\n    if (afterEffect) { afterEffect(child, ctx, opt); }\r\n\r\n    return this.run(\"afterSet\", [child, ctx], opt);\r\n  }\r\n\r\n  set(child, opt={}, afterEffect) {\r\n    const context = this.getContext(child, true);\r\n    const key = this.validateKey(child.getKey(true), \"set\", opt.throwError);\r\n    if (!Array.isArray(context)) { return this._set(context, key, child, opt, afterEffect); }\r\n    let ok = true;\r\n    for (const ctx of context) { ok = (this._set(ctx, key, child, opt, afterEffect)) && ok; }\r\n    return ok;\r\n  }\r\n\r\n  _remove(context, key, child, opt={}, afterEffect) {\r\n    const { context:ctx, index, list } = this.getData(context, opt.throwError);\r\n    const id = list.indexOf(child);\r\n\r\n    if (id < 0) {\r\n      if (opt.throwError !== false) { throw Error(this.msg(`remove(...) failed - missing`, key, ctx)); }\r\n      return false;\r\n    }\r\n\r\n    if (!(this.run(\"beforeRemove\", [child, ctx], opt))) { return false; }\r\n\r\n    if (list.length === 1) { delete this.data[ctx]; } else {\r\n      list.splice(id, 1);\r\n      delete index[key];\r\n    }\r\n\r\n    if (afterEffect) { afterEffect(child, ctx, opt); }\r\n    \r\n    return this.run(\"afterRemove\", [child, ctx], opt);\r\n  }\r\n\r\n  remove(child, opt={}, afterEffect) {\r\n    const context = this.getContext(child, false);\r\n    const key = this.validateKey(child.getKey(false), \"remove\", opt.throwError);\r\n    if (!Array.isArray(context)) { return this._remove(context, key, child, opt, afterEffect); }\r\n    let ok = true;\r\n    for (const ctx of context) { ok = (this._remove(ctx, key, child, opt, afterEffect)) && ok; }\r\n    return ok;\r\n  }\r\n\r\n  exist(key, context, throwError = false) {\r\n    const { context:ctx, index } = this.getData(context, throwError);\r\n    key = this.validateKey(key, \"exist\", throwError);\r\n    if (index.hasOwnProperty(key)) { return true; }\r\n    if (throwError) { throw Error(this.msg(`exist failed - not exist`, key, ctx)); }\r\n    return false;\r\n  }\r\n\r\n  get(key, context, throwError = true) {\r\n    const { context:ctx, index } = this.getData(context, throwError);\r\n    key = this.validateKey(key, \"get\", throwError);\r\n    const child = index[key];\r\n    if (child) { return child; }\r\n    if (throwError) { throw Error(this.msg(`get failed - not exist`, key, ctx)); }\r\n  }\r\n\r\n  map(callback, opt={}) {\r\n    const { context, throwError, filter, orderBy, stopable, byKey } = opt;\r\n    const { list, index } = this.getData(context, throwError);\r\n    const optPass = { filter, orderBy, stopable};\r\n    return byKey ? _.map(index, callback, optPass) : _.list(list, callback, optPass);\r\n  }\r\n\r\n  find(checker, opt={}) {\r\n    const { context, throwError, filter, orderBy, stopable } = opt;\r\n    const { list } = this.getData(context, throwError);\r\n    return _.find(list, checker, { filter, orderBy, stopable });\r\n  }\r\n\r\n}", "import jet from \"@randajan/jet-core\";\r\n\r\nexport class Transactions {\r\n\r\n    constructor(onError) {\r\n        this.ticks = 0;\r\n        this.state = \"ready\";\r\n        this.queue = [];\r\n        this.onError = jet.isRunnable(onError) ? onError : ()=>{};\r\n        //this.last\r\n        //this.error\r\n    }\r\n\r\n    execute(name, execution, opt={ stopOnError:false, throwError:true }) {\r\n        const exe = last=>{\r\n            try { last; } catch(e) {}\r\n\r\n            if (this.queue[0] === exe) { return false; } //it was removed before it started\r\n            else { this.queue.shift(); }\r\n\r\n            //transaction before raised in error and it has stopOnError parametr active\r\n            let isErr = this.state === \"error\";\r\n            let err = this.error; \r\n\r\n            if (!isErr) { \r\n                this.state = name;\r\n                try { execution(this.ticks++); } catch(e) { isErr = true; err = e; }\r\n                this.state = (isErr || opt.stopOnError === false) ? \"ready\" : \"error\";\r\n                if (this.state === \"error\") { this.onError(this.error = err); }\r\n            }\r\n            \r\n            if (isErr && opt.throwError !== false) { throw err; }\r\n            \r\n            return !isErr;\r\n        }\r\n\r\n        return this.last = exe(this.last);\r\n    }\r\n\r\n    reset() {\r\n        this.state = \"ready\";\r\n        this.queue = [];\r\n    }\r\n\r\n\r\n}", "import jet from \"@randajan/jet-core\";\r\nimport { events, vault } from \"../../uni/consts.js\";\r\nimport { Chop } from \"../privates/Chop.js\";\r\nimport { Step } from \"../privates/Step.js\";\r\nimport { Row } from \"./Row.js\";\r\n\r\nconst { solid } = jet.prop;\r\n\r\nconst initStep = (table, vals) => {\r\n  const step = Step.create(table);\r\n  if (jet.isMapable(vals)) { step.push(vals); }\r\n  return step;\r\n}\r\n\r\nexport class Rows extends Chop {\r\n  constructor(table, stream) {\r\n\r\n    super(`${table.name}.rows`, {\r\n      childName: \"row\",\r\n      defaultContext: \"all\",\r\n      stream,\r\n      loader: (rows, bundle, data) => {\r\n        for (let index in data) {\r\n          const vals = data[index];\r\n          if (!jet.isMapable(vals)) { return; }\r\n          Row.create(rows, _p.onSave).set(vals, { throwError: false, silentSave: true });\r\n        }\r\n      }\r\n    });\r\n\r\n    const _p = vault.get(this);\r\n\r\n    const save = (row, opt={}, afterEffect) => {\r\n      const keySaved = row.key;\r\n      const wasRemoved = row.isRemoved;\r\n      const key = row.live.key;\r\n      const isRemoved = row.live.isRemoved;\r\n    \r\n      const rekey = key !== keySaved;\r\n      const remove = isRemoved !== wasRemoved;\r\n    \r\n      if (key && !isRemoved) {\r\n        if (rekey) { _p.bundle.set(row, opt, afterEffect); }\r\n        else {\r\n          _p.bundle.run(\"beforeUpdate\", [row, undefined], opt);\r\n          if (afterEffect) { afterEffect(row, undefined, opt); }\r\n          _p.bundle.run(\"afterUpdate\", [row, undefined], opt);\r\n        }\r\n      }\r\n      if (keySaved && (rekey || remove)) { _p.bundle.remove(row, opt, afterEffect); }\r\n    \r\n    }\r\n\r\n    _p.onSave = (...args) => this.isLoading ? save(...args) : _p.transactions.execute(\"saving\", _ => save(...args));\r\n\r\n    solid.all(this, {\r\n      db:table.db,\r\n      table,\r\n    }, false);\r\n\r\n    //translate primitive events to extra events\r\n    for (const [when, action, name] of events.primitive) {\r\n      this.on(name, (row, ctx, opt)=>{\r\n        if (this.state === \"loading\" || opt.silentSave) { return; }\r\n        return _p.bundle.run(when+\"Save\", [action, row], opt);\r\n      });\r\n      this.on(name, (row, ctx, opt)=>{\r\n        if (this.state === \"loading\") { return; }\r\n        return _p.bundle.run(when+\"Change\", [action, row], opt);\r\n      });\r\n    }\r\n\r\n  }\r\n\r\n  exist(key, throwError = false) {\r\n    return super.exist(key, undefined, throwError);\r\n  }\r\n\r\n  get(key, throwError = true) {\r\n    return super.get(key, undefined, throwError);\r\n  }\r\n\r\n  count(throwError = true) {\r\n    return super.count(undefined, throwError);\r\n  }\r\n\r\n  getList(throwError = true) {\r\n    return super.getList(undefined, throwError);\r\n  }\r\n\r\n  getIndex(throwError = true) {\r\n    return super.getIndex(undefined, throwError);\r\n  }\r\n\r\n  addOrUpdate(vals, opt = { add: true, update: true, autoSave: true, resetOnError: true, throwError: true }) {\r\n    const { table } = this;\r\n    const _p = vault.get(this);\r\n    this.untilLoaded(); //load\r\n    _p.transactions.last; //any operation\r\n\r\n    let step, key;\r\n    const ck = table.cols.primary;\r\n    if (!ck.formula && !ck.resetIf) { key = ck.toRaw(ck.fetch(vals)); } // quick key\r\n    if (key == null) { step = initStep(table, vals); key = step.getKey(); }\r\n    if (key == null) { if (opt.throwError !== false) { throw Error(this.msg(\"push failed - missing key\", vals)); } return; }\r\n\r\n    const rowFrom = this.get(key, false);\r\n\r\n    if (opt.update !== false) {\r\n      if (rowFrom) { rowFrom.update(vals, opt); return rowFrom; }\r\n      if (!opt.add) { if (opt.throwError !== false) { throw Error(this.msg(\"update failed - key not found\", key)); } return; }\r\n    }\r\n\r\n    if (opt.add !== false) {\r\n      if (rowFrom) { if (opt.throwError !== false) { throw Error(this.msg(\"add failed - duplicate key\", key)); } return; }\r\n      const rowTo = Row.create(this, _p.onSave, step || initStep(table, vals));\r\n      if (opt.autoSave !== false) { rowTo.save(opt); }\r\n      return rowTo;\r\n    }\r\n\r\n  }\r\n\r\n  add(vals, opt = { autoSave: true, resetOnError: true, throwError: true }) {\r\n    opt.add = true;\r\n    opt.update = false;\r\n    return this.addOrUpdate(vals, opt);\r\n  }\r\n\r\n  update(vals, opt = { autoSave: true, resetOnError: true, throwError: true }) {\r\n    opt.add = false;\r\n    opt.update = true;\r\n    return this.addOrUpdate(vals, opt);\r\n  }\r\n\r\n  addChop(name, opt = {}) {\r\n    return super.addChop(name, {\r\n      ...opt,\r\n      loader: (chop, bundle) => {\r\n        chop.on(\"afterReset\", this.on(\"beforeUpdate\", row=>bundle.remove(row)), false);\r\n        chop.on(\"afterReset\", this.on(\"afterUpdate\", row=>bundle.set(row)), false);\r\n      }\r\n    });\r\n  }\r\n\r\n  chopByCol(colName, filter, cacheAs = true, morphSeparator=\"$$\") {\r\n    const c = this.table.cols(colName);\r\n    const { separator, ref, isMorph } = c;\r\n    const extra = { isRef:!!ref, isMorph };\r\n    const toRaw = !isMorph ? v=>c._toRaw(v) : v=>{ if (v) { return v.table.name + morphSeparator + v.key } }\r\n    if (isMorph) { extra.morphSeparator = morphSeparator; }\r\n\r\n    return this.addChop(\r\n      typeof cacheAs == \"string\" ? cacheAs : colName,\r\n      {\r\n        useCache: cacheAs,\r\n        getContext: row => {\r\n          if (filter && (filter(row)) === false) { return; }\r\n          const val = row.saved?.get(colName);\r\n          if (!separator) { return toRaw(val, row); }\r\n          let res = [];\r\n          for (const v of val) {\r\n            const r = toRaw(v, row);\r\n            if (r != null) { res.push(r); }\r\n          }\r\n          return res;\r\n        },\r\n        extra\r\n      }\r\n    );\r\n\r\n  }\r\n\r\n}", "import jet from \"@randajan/jet-core\";\r\nimport { Wrap } from \"../interfaces/Wrap\";\r\nimport { evaluate } from \"../tools\";\r\n\r\nconst { solid, virtual } = jet.prop;\r\n\r\nexport class Step {\r\n\r\n  static is(any) { return any instanceof Step; }\r\n\r\n  static create(table, before) { return new Step(table, before); }\r\n\r\n  constructor(table, before) {\r\n\r\n    this.key = before?.key;\r\n    let state = \"ready\";\r\n\r\n    solid.all(this, {\r\n      db: table.db,\r\n      table,\r\n      wrap:Wrap.create(table, this),\r\n      lock:_=>state !== \"ready\" ? false : ((state = \"locked\") && true),\r\n      unlock:_=>state !== \"locked\" ? false : ((state = \"ready\") && true),\r\n      retire:_=>{ before = null; state = \"retired\"; }\r\n    }, false);\r\n\r\n    virtual.all(this, {\r\n      before:_=>before,\r\n      state:_=>state,\r\n      label:_=>this.pull(table.cols.label),\r\n      isExist:_=>!this.isRemoved && table.rows.exist(this.key),\r\n      isDirty:_=>!!this.changeList.length || this.key !== before?.key || !this.isRemoved !== !(before?.isRemoved)\r\n    });\r\n\r\n    this.reset();\r\n  }\r\n\r\n  getKey() { return this.key; }\r\n\r\n  pull(col) {\r\n    if (!col) { return; }\r\n\r\n    const { vals, raws, vStamp, vSolid, before, wrap } = this;\r\n    const { isVirtual, init, resetIf, formula, isReadonly, separator } = col;\r\n    const cacheStamp = col.getCacheStamp();\r\n\r\n    if (vals.hasOwnProperty(col) && (!isVirtual || vStamp[col] === cacheStamp)) {\r\n      const cval = vals[col];\r\n      return (separator && cval) ? [...cval] : cval; //revive cached value\r\n    }\r\n\r\n    let raw = raws[col];\r\n    const self = _ => col.toVal(raw, wrap);\r\n\r\n    if (!vSolid[col]) { //reset raws if is not solid\r\n      vSolid[col] = !isVirtual; //reset everytime if isVirtual\r\n      if (formula) { raw = formula(wrap); } //formula\r\n      else {\r\n        const bew = before ? before.raws[col] : raw;\r\n        if (raw !== bew && isReadonly && isReadonly(wrap, self)) { raw = bew; } //revive value\r\n        if (!before ? (init && raw == null) : (resetIf && resetIf(wrap, self))) { raw = init ? init(wrap) : undefined; } //init or reset\r\n      }\r\n    }\r\n\r\n    const val = self();\r\n    if (cacheStamp) {\r\n      vals[col] = val; //cache value\r\n      vStamp[col] = cacheStamp; //create cacheStamp\r\n    } \r\n\r\n    if (!isVirtual || col.isPrimary) { raws[col] = col.toRaw(val); }\r\n\r\n    return val;\r\n  };\r\n\r\n  push(vals, force = true) {\r\n    if (this.state !== \"ready\") { return false; }\r\n\r\n    const { table: { rows:{ isLoading }, cols }, raws, before } = this;\r\n\r\n    const reals = cols.virtuals.getList(false);\r\n    const changeList = this.changeList = [];\r\n    const changes = this.changes = {};\r\n    this.vals = {};\r\n    this.vStamp = {};\r\n    this.vSolid = {};\r\n\r\n    for (const col of reals) {\r\n      this.vSolid[col] = isLoading; //no reset raws on pull\r\n      const raw = col.fetch(vals);\r\n      if (raw !== undefined) { raws[col] = col.toRaw(raw); }\r\n      else if (force) { delete raws[col]; }\r\n      if (isLoading) {\r\n        changeList.push(col);\r\n        changes[col] = raws[col];\r\n      }\r\n    }\r\n\r\n    if (!isLoading) {\r\n      for (const col of reals) {\r\n        this.pull(col);\r\n        if (before && raws[col] !== before.raws[col]) { //is isDirty column\r\n          changeList.push(col);\r\n          changes[col] = raws[col];\r\n        } \r\n      };\r\n    }\r\n\r\n    this.key = this.pull(cols.primary);\r\n\r\n    return !!changeList.length;\r\n  }\r\n\r\n  get(col, throwError=true) {\r\n    const { table: { cols } } = this;\r\n    if (!Array.isArray(col)) { return this.pull(cols.get(col, throwError !== false)); }\r\n    let row;\r\n    for (const c of col) {\r\n      if (c === col[0]) { row = this.pull(cols.get(c, throwError !== false)); }\r\n      else if (row?.get) { row = row.get(c, throwError); }\r\n      else { return; }\r\n    }\r\n    return row;\r\n  }\r\n\r\n  getRaw(col, throwError=true) {\r\n    const { table: { cols } } = this;\r\n    if (this.raws.hasOwnProperty(col)) { return this.raws[col]; }\r\n    const c = cols(col, throwError);\r\n    if (c && c.isVirtual) { return c.toRaw(this.pull(c)); }\r\n  }\r\n\r\n  eval(selector, opt={}) {\r\n    return evaluate(this, selector, opt);\r\n  }\r\n\r\n  extract(noVals, filter) {\r\n    const { table: { cols } } = this;\r\n    return cols.map(c=>{\r\n      if (filter && !filter(c)) { return; }\r\n      return !noVals ? this.pull(c) : !c.isVirtual ? this.raws[c] : c.toRaw(this.pull(c));\r\n    }, { byKey:true });\r\n  }\r\n\r\n  remove() {\r\n    if (this.state !== \"ready\") { return false; }\r\n    return this.isRemoved = true;\r\n  }\r\n\r\n  reset() {\r\n    if (this.state !== \"ready\") { return false; }\r\n    const { before} = this;\r\n    this.isRemoved = before?.isRemoved || false;\r\n    this.raws = before ? { ...before.raws } : {}; // raw data stored\r\n    this.vals = before ? { ...before.vals } : {}; // values ready to use\r\n    this.vStamp = before ? { ...before.vStamp } : {}; // keep track of when value was cached\r\n    this.vSolid = before ? { ...before.vSolid } : {}; // keep track of values that should be reseted (formula bug repair)\r\n    this.changeList = [];\r\n    this.changes = {};\r\n    return true;\r\n  }\r\n\r\n}", "import jet from \"@randajan/jet-core\";\r\n\r\nconst { solid, virtual } = jet.prop;\r\n\r\nexport class Wrap extends jet.types.Plex {\r\n\r\n  static is(any) { return any instanceof Wrap; }\r\n\r\n  static create(table, step) { return new Wrap(table, step); }\r\n\r\n  constructor(table, step) {\r\n    const { db, rows, cols } = table;\r\n\r\n    const get = (col, throwError = true) => step.get(col, throwError);\r\n\r\n    super(get);\r\n\r\n    solid.all(this, {\r\n      db,\r\n      table,\r\n      rows,\r\n      get,\r\n      getRaw:(col, throwError=true) => step.getRaw(col, throwError),\r\n      eval:(selector, opt = {}) => step.eval(selector, opt),\r\n      getRaws:filter=>step.extract(true, filter),\r\n      getVals:filter=>step.extract(false, filter)\r\n    }, false);\r\n\r\n    virtual.all(this, {\r\n      key: _ => step.key,\r\n      label: _ => step.label,\r\n      before: _ => step.before?.wrap,\r\n      isExist: _ => step.isExist,\r\n      isDirty: _ => step.isDirty,\r\n      isRemoved: _ => step.isRemoved,\r\n      raws: _ => ({ ...step.raws }),\r\n      vals: _ => cols.map(col => step.pull(col), { byKey: true }),\r\n      changeList: _ => ([...step.changeList]),\r\n      changes: _ => ({ ...step.changes })\r\n    });\r\n\r\n  }\r\n\r\n  chopByRef(tableName, colName, filter, cacheAs = true, morphSeparator = \"$$\") {\r\n    const table = this.db.get(tableName);\r\n    const chop = table.rows.chopByCol(colName, filter, cacheAs, morphSeparator);\r\n    if (chop.extra.isRef) { return chop; }\r\n    throw Error(this.table.msg(`chopByRef table('${tableName}') column('${colName}') failed because column is not ref`));\r\n  }\r\n\r\n  refs(tableName, colName, filter, cache = {}) {\r\n    const chop = (cache.current || (cache.current = this.chopByRef(tableName, colName, filter, false)));\r\n    return chop.getList((chop.extra.isMorph ? this.table.name + chop.extra.morphSeparator : \"\") + this.key, false);\r\n  }\r\n\r\n  getKey() {\r\n    return this.key;\r\n  }\r\n\r\n  toJSON() {\r\n    return this.key || null;\r\n  }\r\n\r\n  toString() {\r\n    return this.key || \"\";\r\n  }\r\n\r\n}", "import jet from \"@randajan/jet-core\";\r\nimport { Step } from \"../privates/Step\";\r\n\r\nconst { solid, virtual } = jet.prop;\r\n\r\nexport class Row extends jet.types.Plex {\r\n\r\n  static create(rows, onSave, iniStep) { return new Row(rows, onSave, iniStep); };\r\n\r\n  constructor(rows, onSave, iniStep) {\r\n    const { db, table } = rows;\r\n    const _p = {};\r\n\r\n    const get = (col, throwError=true) => _p.live.get(col, throwError);\r\n    const push = (vals, force, opt = { autoSave: true, resetOnError: true, throwError: true, silentSave:false }) => {\r\n      return (_p.live.push(vals, force)) && (opt.autoSave === false || this.save(opt));\r\n    }\r\n\r\n    const markAsSaved = _=>{ _p.live = Step.create(table, _p.saved = _p.live); }\r\n\r\n    super(get);\r\n\r\n    solid.all(this, {\r\n      db,\r\n      table,\r\n      rows,\r\n      get,\r\n      getRaw: (col, throwError=true) => _p.live.getRaw(col, throwError),\r\n      eval:(selector, opt = {}) => _p.live.eval(selector, opt),\r\n      set: (vals, opt = { autoSave: true, resetOnError: true, throwError: true }) => push(vals, true, opt),\r\n      update: (vals, opt = { autoSave: true, resetOnError: true, throwError: true }) => push(vals, false, opt),\r\n      reset: _ => !this.isDirty || _p.live.reset(),\r\n      remove: (opt = { autoSave: true, resetOnError: true, throwError: true }) => {\r\n        return _p.live.remove() && (opt.autoSave === false || this.save(opt));\r\n      },\r\n      save: (opt = { resetOnError: true, throwError: true, silentSave:false }) => {\r\n        if (!this.isDirty) { return true; }\r\n        const live = _p.live;\r\n        try {\r\n          live.lock();\r\n          onSave(this, { throwError:true, silentSave:opt.silentSave === true }, markAsSaved);\r\n          live.retire(); // for duration of on(\"after...\") effects row.saved.before is still present\r\n          return true;\r\n        } catch (err) {\r\n          live.unlock();\r\n          if (opt.resetOnError !== false) { this.reset(); }\r\n          if (opt.throwError !== false) { throw err; }\r\n          console.warn(this.msg(err?.message || \"unknown error\"), err?.stack);\r\n          return false;\r\n        }\r\n      }\r\n    }, false);\r\n\r\n    virtual.all(this, {\r\n      key: _ => _p.saved?.key,\r\n      label: _ => _p.saved?.label,\r\n      isRemoved: _ => !_p.saved || _p.saved.isRemoved,\r\n      isExist: _ => !!(_p.saved?.isExist),\r\n      isDirty: _ => _p.live.isDirty,\r\n      live: _ => _p.live.wrap,\r\n      saved: _ => _p.saved?.wrap\r\n    });\r\n\r\n    _p.live = iniStep || Step.create(table);\r\n\r\n  }\r\n\r\n  msg(text) {\r\n    return this.rows.msg(text, this.key || JSON.stringify(this.raws));\r\n  }\r\n\r\n  getKey(isSet) { return isSet ? this.live.key : this.key; }\r\n\r\n  toJSON() {\r\n    return this.key;\r\n  }\r\n\r\n  toString() {\r\n    return this.key || \"\";\r\n  }\r\n\r\n}\r\n", "import jet from \"@randajan/jet-core\";\r\nimport { vault, formatKey } from \"../../uni/consts.js\";\r\nimport { colsTraits } from \"../traits.js\";\r\n\r\nimport { Chop } from \"../privates/Chop.js\";\r\nimport { Col } from \"../interfaces/Col.js\";\r\n\r\n\r\n\r\nconst { solid, virtual } = jet.prop;\r\n\r\nconst loader = (cols, bundle, data) => {\r\n  const _p = vault.get(cols);\r\n  const isArray = Array.isArray(data);\r\n  const { list } = _p.bundle.getData();\r\n\r\n  delete _p.primary;\r\n  delete _p.label;\r\n\r\n  for (const index in data) {\r\n    let value = data[index];\r\n    const isObj = Object.jet.is(value);\r\n\r\n    const name = formatKey((isArray && !isObj) ? value : value.name, index);\r\n    const traits = isObj ? {...value} : {};\r\n\r\n    if (isObj) {\r\n      delete traits.name;\r\n      for (const trait in colsTraits) {\r\n        const v = traits[trait];\r\n        delete traits[trait];\r\n        if (!v) { continue; }\r\n        const prop = colsTraits[trait];\r\n        if (_p[prop]) { throw Error(cols.msg(`${prop} column is allready set as '${_p[prop]}'`, name)); }\r\n        _p[prop] = name;\r\n      }\r\n    }\r\n    \r\n    bundle.set(new Col(cols, list.length, name, traits));\r\n  }\r\n\r\n  if (!list.length) { throw Error(cols.msg(\"at least one column is required\")); }\r\n\r\n  if (!_p.primary) { _p.primary = list[0]; }\r\n  if (!_p.label) { _p.label = _p.primary; }\r\n\r\n}\r\n\r\nexport class Cols extends Chop {\r\n\r\n  constructor(table, stream) {\r\n\r\n    super(`${table.name}.cols`, {\r\n      childName:\"column\",\r\n      defaultContext:\"all\",\r\n      stream,\r\n      loader\r\n    });\r\n\r\n    const _p = vault.get(this);\r\n\r\n    solid.all(this, {\r\n      db:table.db,\r\n      table,\r\n      virtuals:this.addChop(\"virtuals\", { getContext:c=>c.isVirtual, defaultContext:true }),\r\n      refs:this.addChop(\"refs\", { getContext:c=>!!c.ref, defaultContext:true })\r\n    }, false);\r\n  \r\n    virtual.all(this, {\r\n      primary:this.withUntilLoaded(_=>_p.bundle.get(_p.primary)),\r\n      label:this.withUntilLoaded(_=>_p.bundle.get(_p.label))\r\n    });\r\n\r\n  }\r\n\r\n  exist(name, throwError = false) {\r\n    return super.exist(name, undefined, throwError);\r\n  }\r\n\r\n  get(name, throwError = true) {\r\n    return super.get(name, undefined, throwError);\r\n  }\r\n\r\n  count(throwError=true) {\r\n    return super.count(undefined, throwError);\r\n  }\r\n\r\n  getList(throwError=true) {\r\n    return super.getList(undefined, throwError);\r\n  }\r\n\r\n  getIndex(throwError=true) {\r\n    return super.getIndex(undefined, throwError);\r\n  }\r\n\r\n}", "import jet from \"@randajan/jet-core\";\r\nimport { map } from \"@randajan/jet-core/eachSync\";\r\nimport { functionOrNull, numberPositive } from \"../uni/consts\";\r\nimport { breachSelector } from \"../uni/tools\";\r\n\r\n\r\nconst _scopes = [\"global\", \"db\", \"table\", \"self\"];\r\nexport const colsTraits = {\r\n    isPrimary: \"primary\",\r\n    isLabel: \"label\"\r\n};\r\n\r\nconst functionWithCacheOrNull = (trait, col)=>{\r\n    const selector = col.selector;\r\n    const formula = functionOrNull(trait);\r\n    if (!formula) { return selector ? row=>row.eval(selector) : null; }\r\n    const cache = {};\r\n    if (!selector) { return row=>formula(row, cache); }\r\n    return row=>formula(row.eval(selector), row, cache);\r\n}\r\n\r\nexport const colTo = map({\r\n    boolean:{val:Boolean.jet.to},\r\n    string:{val:(v, c)=>String.jet.to(v).substr(0, c.max)},\r\n    ref:{val:String, raw:v=>v.key || v},\r\n    number:{val:(v, c)=>Number.jet.round(Number.jet.frame(Number.jet.to(v), c.min, c.max), c.dec)},\r\n    datetime:{val:v=>v == null ? new Date() : new Date(v)},\r\n    duration:{val:v=>Math.max(0, Math.round(Number.jet.to(v)))},\r\n    object:{val:v=>jet.json.from(v)}\r\n}, t=>t.raw ? t : {...t, raw:t.val});\r\n\r\n\r\nexport const colTraits = {\r\n    type: jet.enumFactory(Object.keys(colTo), {\r\n        before:raw=>String.jet.simplify(String.jet.to(raw)), \r\n        after:(output, col)=>col.ref ? \"ref\" : output != null ? output : \"string\"\r\n    }),\r\n    isReadonly: functionOrNull,\r\n    resetIf: functionOrNull,\r\n    init: functionOrNull,\r\n    selector:val=>(Array.isArray(val) || typeof val === \"string\") ? val : null,\r\n    formula: functionWithCacheOrNull,\r\n    ref: functionOrNull,\r\n    display: (val, col)=>numberPositive(val, col.db.displayDefault),\r\n    separator: String.jet.to,\r\n    isVirtual: Boolean.jet.to,\r\n    isTrusted: Boolean.jet.to,\r\n    isMorph:(val, col)=>typeof col._ref === \"function\",\r\n    dec:(val, col)=>Math.round(numberPositive(val, col.db.decimalDefault)),\r\n    min:val=>val == null ? undefined : Number.jet.to(val),\r\n    max:val=>val == null ? undefined : Number.jet.to(val),\r\n    noNull: Boolean.jet.to,\r\n    extra: Object.jet.to,\r\n    scope: (raw, col)=>{\r\n        if (!col.isVirtual) { return _=>\"self\"; }\r\n        if (typeof raw === \"string\") {\r\n            raw = String.jet.simplify(String.jet.to(raw));\r\n            return _scopes.includes(raw) ? _=>raw : _=>raw.split(\",\");\r\n        }\r\n        if (Array.isArray(raw)) { return _=>[...raw]; }\r\n        if (!col.selector) { return _=>\"self\"; }\r\n\r\n        let ready, pending;\r\n        const tables = new Set(), scopes = new Set();\r\n\r\n        return _=>{\r\n            if (pending) { pending; }\r\n            else if (!ready) {\r\n                (pending = collectDeps(col.cols, col.selector, tables, scopes));\r\n                ready = true;\r\n                pending = null;\r\n            }\r\n            if (scopes.has(\"global\")) { return \"global\"; }\r\n            if (scopes.has(\"db\")) { return \"db\"; }\r\n            if (!tables.size) { return \"self\"; }\r\n    \r\n            return [...tables];\r\n        }\r\n\r\n    }\r\n\r\n};\r\n\r\nconst collectDeps = (cols, selector, tables, scopes)=>{\r\n    if (!cols) { return; }\r\n    if (scopes.has(\"global\") || scopes.has(\"db\")) { return; }\r\n\r\n    breachSelector(selector, \r\n        (alias, path, selector)=>{\r\n            if (path === \"*\") { return; } //not allowed here\r\n            const c = cols(path || selector);\r\n            const s = c.scope();\r\n            if (!Array.isArray(s)) { scopes.add(s); }\r\n            else { for (const t of s) { tables.add(t); } }\r\n            if (!c._ref) { return; }\r\n            if (c.isMorph) { scopes.add(\"db\"); return; }\r\n            if (!path) { return; }\r\n            tables.add(c._ref);\r\n            const tbl = cols.db(c._ref);\r\n            return collectDeps(tbl.cols, selector, tables, scopes);\r\n        },\r\n        arr=>arr.map(selector=>collectDeps(cols, selector, tables, scopes))\r\n    );\r\n}\r\n", "import jet from \"@randajan/jet-core\";\r\nimport { vault } from \"../../uni/consts\";\r\nimport { evaluate } from \"../tools\";\r\nimport { colTraits, colTo, } from \"../traits\";\r\n\r\nconst { solid, virtual, cached } = jet.prop;\r\n\r\nconst cacheStampFactory = col=>{\r\n    const { db, table } = col;\r\n    const scope = col.scope();\r\n    if (scope === \"self\") { return _=>1; }\r\n    if (scope === \"table\") { return _=>table.lastChange; }\r\n    if (scope === \"db\") { return _=>db.lastChange; }\r\n    if (scope === \"global\") { return _=>0; }\r\n    \r\n    const getLastChanges = tn=>db(tn).lastChange;\r\n    return _=>Math.max(...scope.map(getLastChanges));\r\n}\r\n\r\nexport class Col {\r\n\r\n    constructor(cols, id, name, traits) {\r\n        const { db, table } = cols;\r\n        const _c = vault.get(cols);\r\n        const _p = {};\r\n\r\n        let _gcs;\r\n        solid.all(this, {\r\n            db,\r\n            table,\r\n            cols,\r\n            getCacheStamp: _=>(_gcs || (_gcs = cacheStampFactory(this)))(),\r\n            _ref:traits.ref\r\n        }, false);\r\n\r\n        solid.all(this, {\r\n            id,\r\n            name\r\n        });\r\n        \r\n        virtual.all(this, {\r\n            isPrimary: _ => _c.primary === name,\r\n            isLabel: _ => _c.label === name\r\n        });\r\n\r\n        for (const tn in colTraits) {\r\n            const trait = traits[tn];\r\n            delete traits[tn];\r\n            cached(this, _p, tn, _=>colTraits[tn](trait, this));\r\n        }\r\n\r\n        if (this.isVirtual && !this.formula) {\r\n            throw Error(this.msg(\"virtual column require formula to be set\"));\r\n        }\r\n\r\n        if (this.ref && (this.isPrimary || this.isLabel)) {\r\n            throw Error(this.msg(\"columns with ref couldn't be primary or label\"));\r\n        }\r\n\r\n        const unknownTraits = Object.keys(traits);\r\n\r\n        if (unknownTraits.length) {\r\n            throw Error(this.msg(`unknown trait${unknownTraits.length > 1 ? \"s\" : \"\"} '${unknownTraits.join(\"', '\")}'`));\r\n        }\r\n\r\n    }\r\n\r\n    get(trait, throwError=true) {\r\n        if (trait === \"name\" || colTraits[trait]) { return this[trait]; }\r\n        if (throwError) { throw Error(`unknown trait '${trait}'`); }\r\n    }\r\n\r\n    eval(selector, opt={}) {\r\n        return evaluate(this, selector, opt);\r\n    }\r\n\r\n    msg(text) {\r\n        return this.cols.msg(text, this.name);\r\n    }\r\n\r\n    getKey() { return this.name; }\r\n\r\n    _toRaw(val) {\r\n        if (val != null || this.noNull) { return colTo[this.type].raw(val, this); }\r\n    }\r\n\r\n    toRaw(val) {\r\n        const { separator } = this;\r\n        if (!separator) { return this._toRaw(val); }\r\n        if (!Array.isArray(val)) { val = Array.jet.to(String.jet.to(val, separator)); }\r\n        let raw = \"\";\r\n        for (let v of val) {\r\n            v = this._toRaw(v);           \r\n            if (v == null || v == \"\") { continue; }\r\n            raw += (raw ? separator : \"\") + v;\r\n        }\r\n        if (raw) { return raw; }\r\n    }\r\n\r\n    _toVal(raw, refName) {\r\n        if (raw != null || this.noNull) { raw = colTo[this.type].val(raw, this); }\r\n        if (raw != null) { return refName ? (this.db(refName)).rows.get(raw, false) : raw; }\r\n    }\r\n\r\n    toVal(raw, row) {\r\n        const { separator, ref, isTrusted } = this;\r\n        const refName = (ref && row) ? ref(row) : null;\r\n\r\n        if (!separator) { return this._toVal(raw, refName); }\r\n\r\n        const list = raw == null ? [] : Array.isArray(raw) ? raw : String(raw).split(separator);\r\n        if (!list.length || (isTrusted && raw === list)) { return list; }\r\n\r\n        for (let i in list) { list[i] = this._toVal(list[i], refName); }\r\n\r\n        return list;\r\n    }\r\n\r\n    fetch(vals) {\r\n        return Array.isArray(vals) ? vals[this.id] : vals ? vals[this.name] : undefined;\r\n    }\r\n\r\n    toJSON() {\r\n        return this.name || null;\r\n    }\r\n\r\n    toString() {\r\n        return this.name || \"\";\r\n    }\r\n\r\n}", "\r\n\r\nexport const toRefId = ref=>(typeof ref !== \"string\") ? ref?.id : ref;\r\n\r\nexport const isFce = fce=>typeof fce === \"function\";\r\nexport const toFce = (fce, defReturn)=>isFce(fce) ? fce : ()=>defReturn;\r\nexport const wrapFce = (wrap, what)=>(...args)=>wrap(what(...args));\r\n\r\nexport const toStr = (any, def)=>any != null ? String(any) : def;\r\nexport const toArr = (any)=>any instanceof Array ? any : [any];\r\n\r\nexport const toNum = (val, min, max, dec)=>{\r\n    val = Number(val);\r\n    if (isNaN(val)) { return val; }\r\n    if (max != null) { val = Math.min(val, max); }\r\n    if (min != null) { val = Math.max(val, min); }\r\n    if (dec == 0) { val = Math.round(val); }\r\n    else if (dec > 0) {\r\n        const pow = Math.pow(10, dec);\r\n        val = Math.round(val*pow)/pow;\r\n    }\r\n    return val;\r\n}\r\n\r\nconst _bols = /^(0|n|no|not|off|false)$/i;\r\nexport const toBol = val=>typeof val !== \"string\" ? !!val : !_bols.test(val);\r\n\r\nexport const toDate = (val, min, max)=>{\r\n    if (!(val instanceof Date)) { return new Date(toNum(val, min, max)); }\r\n    if (min == null && max == null) { return val; }\r\n    return new Date(toNum(x.getTime(), min, max));\r\n}\r\n\r\nconst _arg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\r\nconst parseFceArgs = (args)=>{\r\n    if (args) { args = args.trim(); }\r\n    if (!args) { return []; }\r\n\r\n    if (!args.startsWith(\"(\")) { return _arg.test(args) ? [args] : undefined; }\r\n    if (!args.endsWith(\")\")) { return; }\r\n\r\n    args = args.slice(1, -1).trim(); //remove braces;\r\n    if (!args) { return []; }\r\n\r\n    let result = [];\r\n    for (let a of args.split(\",\")) {\r\n        a = a.trim();\r\n        if (!_arg.test(a)) { return; }\r\n        result.push(a);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport const parseFce = (val)=>{\r\n    const t = typeof val;\r\n    if (t === \"function\") { return val; }\r\n    if (t !== \"string\") { return _=>val; }\r\n\r\n    const frags = val.trim().split(\"=>\");\r\n    if (frags.length <= 1) { return _=>val; }\r\n\r\n    const args = parseFceArgs(frags.shift());\r\n    if (!args) { return _=>val; }\r\n\r\n    let body = frags.join(\"=>\").trim();\r\n    if (!body.startsWith(\"{\")) { body = \"return \"+body; }\r\n    else if (!body.endsWith(\"}\")) { return _=>val; }\r\n    else { body = body.slice(1, -1).trim(); }\r\n\r\n    return new Function(args, body);\r\n}", "import { vault } from \"../../uni/consts\";\r\n\r\nconst prepareRecs = (chop, recsByGroupId, groupId, throwError = true, autoCreate = false)=>{\r\n    let recs = recsByGroupId.get(groupId);\r\n    if (recs) { return recs; }\r\n    if (autoCreate) { recsByGroupId.set(groupId, recs = new Map()); }\r\n    else if (throwError) { throw Error(chop.msg(`not found`, {group:groupId})); }\r\n    return recs;\r\n};\r\n\r\nexport const deleteRec = (chop, recsByGroupId, groupId, rec)=>{\r\n    const recs = prepareRecs(chop, recsByGroupId, groupId, true, false);\r\n\r\n    if (!recs?.has(rec.id)) { throw Error(chop.msg(`delete(...) critical error - inconsistency`, { group:groupId, row:rec.id }));}\r\n\r\n    if (recs.size <= 1) { recsByGroupId.delete(groupId); }\r\n    else { recs.delete(rec.id); }\r\n}\r\n\r\nexport const setRec = (chop, recsByGroupId, groupId, rec)=>{\r\n    const recs = prepareRecs(chop, recsByGroupId, groupId, false, true);\r\n\r\n    const current = recs.get(rec.id);\r\n\r\n    if (!current) { recs.set(rec.id, rec); return; }\r\n    if (current === rec) { return; }\r\n\r\n    throw Error(chop.msg(`add(...) failed - duplicate`, { group:groupId, row:rec.id }));\r\n}\r\n\r\n\r\nexport const getRec = (chop, groupId, recId, throwError = false)=>{\r\n\r\n    if (!recId) {\r\n        if (throwError) { throw Error(chop.msg(`get(...) failed - id undefined`, { group:groupId })); }\r\n        return;\r\n    }\r\n\r\n    const { recsByGroupId } = vault.get(chop);\r\n    const recs = prepareRecs(chop, recsByGroupId, groupId, throwError, false);\r\n\r\n    return recs?.get(recId);\r\n}\r\n\r\nexport const getRecs = (chop, groupId, throwError = false)=>{\r\n    const { recsByGroupId } = vault.get(chop);\r\n    return prepareRecs(chop, recsByGroupId, groupId, throwError, false);\r\n}\r\n\r\nexport const getAllRecs = chop=>vault.get(chop).groupIdsByRec;\r\n", "import { vault } from \"../../uni/consts\";\r\nimport { deleteRec } from \"./_bits\";\r\nimport { runEvent } from \"./eventHandlers\";\r\n\r\n\r\nexport const afterRemove = (chop, rec, ctx)=>{\r\n    const { isMultiGroup, recsByGroupId, groupIdsByRec, filter, handlers, childs, state } = vault.get(chop);\r\n\r\n    const current = groupIdsByRec.get(rec);\r\n    if (!current) {\r\n        if (filter(rec)) { throw Error(chop.msg(`remove(...) failed - missing`, { row:rec.id })); }\r\n        return false;\r\n    }\r\n\r\n    if (isMultiGroup) {\r\n        for (const groupId of current) { deleteRec(chop, recsByGroupId, groupId, rec); }\r\n    } else {\r\n        deleteRec(chop, recsByGroupId, current, rec);\r\n    }\r\n    \r\n    groupIdsByRec.delete(rec);\r\n\r\n    return runEvent(handlers, childs, state, \"remove\", rec, ctx);\r\n}\r\n", "import { vault } from \"../../uni/consts\";\r\nimport { runEvent } from \"./eventHandlers\";\r\n\r\nexport const afterReset = (chop, ctx)=>{\r\n    const _p = vault.get(chop);\r\n    const { recsByGroupId, groupIdsByRec, init, handlers, childs, state } = _p;\r\n    \r\n    groupIdsByRec.clear();\r\n    recsByGroupId.clear();\r\n    \r\n    _p.state = \"init\";\r\n    init(chop, ctx);\r\n\r\n    _p.state = \"reset\";\r\n    runEvent(handlers, childs, _p.state, \"reset\", undefined, ctx);\r\n\r\n    _p.state = \"ready\";\r\n    return true;\r\n}", "import { vault } from \"../../uni/consts\";\r\nimport { deleteRec, setRec } from \"./_bits\";\r\nimport { runEvent } from \"./eventHandlers\";\r\n\r\n\r\nexport const afterUpdate = (chop, rec, ctx)=>{\r\n    const { isMultiGroup, recsByGroupId, groupIdsByRec, group, filter, handlers, childs, state } = vault.get(chop);\r\n\r\n    const current = groupIdsByRec.get(rec);\r\n    if (!current) {\r\n        if (filter(rec)) { throw Error(chop.msg(`update(...) failed - missing`, { row:rec.id })); }\r\n        return false;\r\n    }\r\n\r\n    const valid = chop.getGroup(rec);\r\n\r\n    if (isMultiGroup) {\r\n        const results = new Set();\r\n\r\n        for (const groupId of valid) {\r\n            if (results.has(groupId)) { continue; } //duplicate control\r\n            results.add(groupId);\r\n            if (current.has(groupId)) { current.delete(groupId); continue; } //remove valid current\r\n            setRec(chop, recsByGroupId, groupId, rec); //add new\r\n        }\r\n\r\n        for (const groupId of current) {\r\n            deleteRec(chop, recsByGroupId, groupId, rec); //remove old\r\n        }\r\n\r\n        groupIdsByRec.set(rec, results);\r\n\r\n    } else if (valid !== current) {\r\n        setRec(chop, recsByGroupId, valid, rec);\r\n        deleteRec(chop, recsByGroupId, current, rec);\r\n        groupIdsByRec.set(rec, valid);\r\n    }\r\n\r\n    return runEvent(handlers, childs, state, \"update\", rec, ctx);\r\n}", "import { vault } from \"../../uni/consts\";\r\nimport { isFce } from \"../../uni/formats\";\r\nimport { afterAdd } from \"./afterAdd\";\r\nimport { afterRemove } from \"./afterRemove\";\r\nimport { afterReset } from \"./afterReset\";\r\nimport { afterUpdate } from \"./afterUpdate\";\r\n\r\n\r\nexport const runEvent = (handlers, childs, state, event, rec, ctx)=>{\r\n\r\n    if (childs.size && state !== \"init\") {\r\n        if (event === \"reset\") {\r\n            for (const child of childs) { afterReset(child, ctx); }\r\n        }\r\n        else if (event === \"add\") {\r\n            for (const child of childs) { afterAdd(child, rec, ctx); }\r\n        }\r\n        else if (event === \"remove\") {\r\n            for (const child of childs) { afterRemove(child, rec, ctx); }\r\n        }\r\n        else if (event === \"update\") {\r\n            for (const child of childs) { afterUpdate(child, rec, ctx); }\r\n        }\r\n    }\r\n\r\n    if (handlers?.length) {\r\n        for (let i = handlers.length - 1; i >= 0; i--) {\r\n            try { if (handlers[i]) { handlers[i](event, rec, ctx); } }\r\n            catch(err) { console.error(err); }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport const onEvent = (chop, callback, onlyOnce = false)=>{\r\n    if (!isFce(callback)) { throw Error(chop.msg(`on(...) require callback`)); }\r\n    const { handlers } = vault.get(chop);\r\n\r\n    let remove;\r\n    const cb = onlyOnce ? (...args) => { callback(...args); remove(); } : callback;\r\n\r\n    handlers.unshift(cb);\r\n\r\n    return remove = _ => {\r\n        const x = handlers.indexOf(cb);\r\n        if (x >= 0) { handlers.splice(x, 1); }\r\n        return callback;\r\n    }\r\n}", "import { vault } from \"../../uni/consts\";\r\nimport { setRec } from \"./_bits\";\r\nimport { runEvent } from \"./eventHandlers\";\r\n\r\n\r\nexport const afterAdd = (chop, rec, ctx)=>{\r\n    const { isMultiGroup, recsByGroupId, groupIdsByRec, filter, group, handlers, childs, state } = vault.get(chop);\r\n    if (!filter(rec)) { return false; }\r\n\r\n    const valid = chop.getGroup(rec);\r\n    if (isMultiGroup) {\r\n        const results = new Set();\r\n\r\n        for (const groupId of valid) {\r\n            if (results.has(groupId)) { continue; }\r\n            setRec(chop, recsByGroupId, groupId, rec);\r\n            results.add(groupId);\r\n        }\r\n\r\n        groupIdsByRec.set(rec, results);\r\n\r\n    } else {\r\n        setRec(chop, recsByGroupId, valid, rec)\r\n        groupIdsByRec.set(rec, valid);\r\n    }\r\n\r\n    return runEvent(handlers, childs, state, \"add\", rec, ctx);\r\n}", "import { vault } from \"../../uni/consts\";\r\n\r\nimport { toArr, toFce, toStr, wrapFce } from \"../../uni/formats\";\r\nimport { afterAdd } from \"../effects/afterAdd\";\r\nimport { onEvent } from \"../effects/eventHandlers\";\r\nimport { getAllRecs, getRec, getRecs } from \"../effects/_bits\";\r\nimport { afterReset } from \"../effects/afterReset\";\r\nimport { solids, virtuals } from \"@randajan/props\";\r\n\r\n\r\nexport class Chop {\r\n\r\n    constructor(id, opt={}, parent) {\r\n        id = toStr(id);\r\n        if (!id) { throw Error(this.msg(\"critical error - missing id\")); }\r\n\r\n        const { init, group, autoReset=true, isMultiGroup=false } = opt;\r\n        const filter = toFce(opt.filter, true);\r\n\r\n        const _p = {\r\n            state:\"pending\",\r\n            handlers:[],\r\n            childs:new Set(),\r\n            groupIdsByRec:new Map(), // rec -> groupIds\r\n            recsByGroupId:new Map(), // groupId -> recs\r\n            isMultiGroup,\r\n            init:toFce(init),\r\n            filter:parent ? rec=>(parent.getGroup(rec) === id && filter(rec)) : filter,\r\n        }\r\n\r\n        solids(this, {\r\n            db:parent?.db || this,\r\n            parent,\r\n            getGroup:!isMultiGroup ? toFce(group) : wrapFce(toArr, toFce(group, [undefined]))\r\n        }, false);\r\n\r\n        solids(this, {\r\n            id:parent ? (parent.id + \".\" + id) : id,\r\n            isMultiGroup\r\n        });\r\n\r\n        virtuals(this, {\r\n            state:_=>_p.state,\r\n            size:_=>_p.groupIdsByRec.size,\r\n            childs:_=>[..._p.childs],\r\n        });\r\n\r\n        vault.set(this, _p);\r\n\r\n        if (parent) {\r\n            const _pp = vault.get(parent);\r\n            _p.init = (_, ctx)=>{\r\n                for (const [rec] of _pp.groupIdsByRec) { afterAdd(this, rec, false, ctx); }\r\n            }\r\n            _pp.childs.add(this);\r\n        }\r\n\r\n        if (autoReset) { this.reset(); }\r\n\r\n    }\r\n\r\n    msg(text, details={}) {\r\n        let msg = this.id;\r\n        for (let i in details) { msg += ` ${i}[${details[i]}]`; }\r\n        if (text) { msg += \" \" + text; }\r\n        return msg.trim();\r\n    }\r\n\r\n    on(callback, onlyOnce = false) {\r\n        return onEvent(this, callback, onlyOnce);\r\n    }\r\n\r\n    reset(ctx) {\r\n        return afterReset(this, ctx);\r\n    }\r\n\r\n    get(groupId, recId, throwError = false) {\r\n        return getRec(this, groupId, recId, throwError);\r\n    }\r\n\r\n    getMap(groupId, throwError = false) {\r\n        const recs = getRecs(this, groupId, throwError);\r\n        return recs ? new Map(recs) : new Map(); \r\n    }\r\n\r\n    getList(groupId, throwError = false) {\r\n        const recs = getRecs(this, groupId, throwError);\r\n        return recs ? recs.values() : []; \r\n    }\r\n\r\n    getAll() {\r\n        return getAllRecs(this).keys();\r\n    }\r\n\r\n    chop(id, opt={}) {\r\n        return new Chop(id, opt, this);\r\n    }\r\n}", "import { fceNone, fcePass, fceTrue } from \"../uni/consts\";\r\nimport { parseFce, toBol, toDate, toNum, toStr } from \"../uni/formats\"\r\n\r\nconst getter = fcePass;\r\nconst setter = fcePass;\r\nconst isRequired = fceTrue;\r\nconst isReadonly = fceTrue;\r\n\r\nexport const meta = {\r\n    \"_ents\": {\r\n        \"_ents\": { },\r\n        \"_cols\": { },\r\n        \"_types\": { }\r\n    },\r\n    \"_types\": {\r\n        \"string\": { setter:(v, c)=>toStr(v, \"\").substr(0, c.max), getter },\r\n        \"boolean\": { setter:(v, c)=>toBol(v), getter },\r\n        \"number\": { setter:(v, c)=>toNum(v, c.min, c.max, c.dec), getter },\r\n        \"datetime\": { setter:(v, c)=>toDate(v, c.min, c.max), getter },\r\n        \"duration\": { setter:(v, c)=>toNum(v, c.min > 0 ? c.min : 0, c.max, 0), getter },\r\n        \"function\": { setter:(v, c)=>parseFce(v), getter },\r\n        \"object\": { setter:(v, c)=>typeof v == \"string\" ? JSON.parse(v) : {}, getter },\r\n        \"ref\": { setter, getter },\r\n        \"nref\": { setter, getter },\r\n        \"any\": { setter, getter }\r\n    },\r\n    \"_cols\": {\r\n        \"_ents-isMeta\":{\r\n            ent: \"_ents\", name: \"isMeta\", type: \"boolean\", isReadonly,\r\n        },\r\n        \"_ents-cols\":{\r\n            ent: \"_ents\", name: \"cols\", type: \"nref\", ref:\"_cols\", parent:\"_cols-ent\", noCache:true,\r\n        },\r\n\r\n        //_types\r\n        \"_types-isMeta\":{\r\n            ent: \"_types\", name: \"isMeta\", type: \"boolean\", isReadonly\r\n        },\r\n        \"_types-setter\":{\r\n            ent: \"_types\", name: \"setter\", type: \"function\", isReadonly, fallback:_=>setter\r\n        },\r\n        \"_types-getter\":{\r\n            ent: \"_types\", name: \"getter\", type: \"function\", isReadonly, fallback:_=>getter\r\n        },\r\n\r\n        //_cols\r\n        \"_cols-isMeta\":{\r\n            ent: \"_cols\", name: \"isMeta\", type: \"boolean\", isReadonly\r\n        },\r\n        \"_cols-ent\":{\r\n            ent: \"_cols\", name: \"ent\", type: \"ref\", ref: \"_ents\", isReadonly, isRequired\r\n        },\r\n        \"_cols-name\":{\r\n            ent: \"_cols\", name: \"name\", type: \"string\", isReadonly, isRequired\r\n        },\r\n        \"_cols-type\":{\r\n            ent: \"_cols\", name: \"type\", type: \"ref\", ref: \"_types\", fallback:_=>\"any\"\r\n        },\r\n        \"_cols-ref\":{\r\n            ent: \"_cols\", name: \"ref\", type: \"ref\", ref: \"_ents\",\r\n        },\r\n        \"_cols-parent\":{\r\n            ent: \"_cols\", name: \"parent\", type: \"ref\", ref: \"_cols\",\r\n        },\r\n        \"_cols-isList\":{\r\n            ent: \"_cols\", name: \"isList\", type: \"boolean\",\r\n        },\r\n        \"_cols-isReadonly\":{\r\n            ent: \"_cols\", name: \"isReadonly\", type: \"function\"\r\n        },\r\n        \"_cols-isRequired\":{\r\n            ent: \"_cols\", name: \"isRequired\", type: \"function\"\r\n        },\r\n        \"_cols-resetIf\":{\r\n            ent:\"_cols\", name:\"resetIf\", type:\"function\"\r\n        },\r\n        \"_cols-init\":{\r\n            ent: \"_cols\", name: \"init\", type: \"function\", //Type should be defined as a function\r\n        },\r\n        \"_cols-fallback\":{\r\n            ent: \"_cols\", name: \"fallback\", type: \"function\", //Type should be defined as a function\r\n        },\r\n        \"_cols-validator\":{\r\n            ent: \"_cols\", name: \"validator\", type:\"function\"\r\n        },\r\n        \"_cols-decimal\":{\r\n            ent: \"_cols\", name: \"decimal\", type: \"number\", decimal: 0, min: 0\r\n        },\r\n        \"_cols-min\":{\r\n            ent: \"_cols\", name: \"min\", type: \"number\",\r\n            //decimal:_=>r.decimal //decimal should be defined as a function\r\n        },\r\n        \"_cols-max\":{\r\n            ent: \"_cols\", name: \"max\", type: \"number\",\r\n            //decimal:_=>r.decimal, min:_=>r.min //decimal & min should be defined as a function\r\n        },\r\n        \"_cols-formula\":{\r\n            ent: \"_cols\", name: \"formula\", type: \"function\",\r\n        },\r\n        \"_cols-noCache\":{\r\n            ent: \"_cols\", name: \"noCache\", type: \"boolean\",\r\n        },\r\n        \"_cols-omitChange\":{\r\n            ent: \"_cols\", name: \"omitChange\", type:\"boolean\"\r\n        }\r\n    }\r\n}\r\n\r\nexport const metaEnt = ent=>{\r\n    return {\r\n        _ent:`_cols`, id:`${ent}-_ent`, ent, name: \"_ent\", type: \"ref\", ref:\"_ents\",\r\n        isReadonly, isRequired, isMeta:true\r\n    }\r\n}\r\n\r\nexport const metaId = (ent, formula)=>{\r\n    return {\r\n        _ent:`_cols`, id:`${ent}-id`, ent, name: \"id\", type: \"string\",\r\n        isReadonly, isRequired, isMeta:true, formula\r\n    }   \r\n}", "import { cacheds, solids } from \"@randajan/props\";\r\nimport { toRefId } from \"../../uni/formats\";\r\nimport { getRec, getRecs } from \"../effects/_bits\";\r\nimport { afterAdd } from \"../effects/afterAdd\";\r\nimport { afterRemove } from \"../effects/afterRemove\";\r\nimport { afterUpdate } from \"../effects/afterUpdate\";\r\nimport { meta } from \"../meta\";\r\nimport { Push } from \"./Push\";\r\n\r\nconst _records = new WeakMap();\r\n\r\nexport const getRecPriv = (db, any, throwError=true)=>{\r\n    const _p = _records.get(any);\r\n    if (_p && (!db || db === _p.db)) { return _p; }\r\n    if (throwError) { throw Error(db.msg(\"is not record\", {row:toRefId(any)})); };\r\n}\r\n\r\nconst createRec = (db, values)=>new RecordPrivate(db, values);\r\n\r\nexport const addRec = (db, values, ctx)=>{\r\n    let res = createRec(db, values);\r\n    if (db.state === \"ready\") { res = res.prepareInit().init(); }\r\n    afterAdd(db, res.current, ctx);\r\n    return res;\r\n}\r\n\r\nexport const addOrSetRec = (db, values, ctx, isUpdate)=>{\r\n    const _rec = createRec(db, values).prepareInit();\r\n    const { _ent, id } = _rec.current;\r\n\r\n    const brother = getRec(db, toRefId(_ent), id);\r\n    if (brother) { return getRecPriv(db, brother).set(values, ctx, isUpdate); }\r\n\r\n    const res = _rec.init();\r\n    afterAdd(db, res.current, ctx);\r\n    return res;\r\n}\r\n\r\nexport const removeRec = (record, ctx, force)=>getRecPriv(this, record).remove(ctx, force);\r\n\r\nclass RecordPrivate {\r\n\r\n    constructor(db, values) {\r\n        const _ent = values._ent = toRefId(values._ent);\r\n        const isMeta = values.isMeta && meta.hasOwnProperty(_ent);\r\n\r\n        const current = {...values}; //interface\r\n        const before = {}; //interface\r\n\r\n        solids(this, {\r\n            db, current, before,\r\n            push:new Push(this),\r\n            isMeta,\r\n        });\r\n\r\n        this.values = values;\r\n        this.state = \"pending\"; //ready, removed;\r\n\r\n        const cols = getRecs(db._cols, _ent);\r\n        if (cols) { for (const [_, col] of cols) { this.addColumn(_records.get(col)); } }\r\n\r\n        _records.set(current, this);\r\n    }\r\n\r\n    msg(text, details={}) {\r\n        return this.db.msg(text, {\r\n            ent:toRefId(this.values._ent),\r\n            row:this.values.id,\r\n            ...details\r\n        });\r\n    }\r\n\r\n    addColumn(_col) {\r\n        const { current, before, state } = this;\r\n\r\n        const { name, formula, noCache } = _col.current;\r\n        const t = _col.traits;\r\n        const isVirtual = (formula != null && noCache != null);\r\n    \r\n        const prop = {\r\n            enumerable:true, configurable:true,\r\n            set:_=>{ throw new Error(this.msg(\"for update use db.update(...) interface\", {column:name})) }\r\n        };\r\n\r\n        if (isVirtual) { prop.get = _=>t.getter(t.setter(this, this.values, this.values[name])); }\r\n        else { prop.get = _=>t.getter(this.push.isPending ? this.push.pull(_col) : this.values[name]); }\r\n        Object.defineProperty(current, name, prop);\r\n\r\n        if (!isVirtual) { prop.get = _=>t.getter(this.values[name]); }\r\n        Object.defineProperty(before, name, prop);\r\n\r\n        if (state === \"ready\") { t.setter(this, this.values, this.values[name], true); }\r\n    }\r\n\r\n    removeColumn(name) {\r\n        const { current, before } = this;\r\n        delete this.values[name];\r\n        delete current[name];\r\n        delete before[name];\r\n    }\r\n\r\n    prepareInit() {\r\n        const { state, push, values } = this;\r\n        if (state === \"pending\") { push.prepare(values); }\r\n        return this;\r\n    }\r\n\r\n    init() {\r\n        const { push } = this;\r\n        this.values = push.execute();\r\n        this.state = \"ready\";\r\n        return push.close();\r\n    }\r\n\r\n    set(input, ctx, isUpdate=false, force=false) {\r\n        const { db, current, push } = this;\r\n\r\n        push.prepare(input, isUpdate);\r\n        this.values = push.execute();\r\n\r\n        if (push.isChanged) {\r\n            afterUpdate(db, current, ctx);\r\n        }\r\n\r\n        return push.close();\r\n    }\r\n\r\n    remove(ctx, force=false) {\r\n        const { db, current, isMeta } = this;\r\n        const errors = new Map();\r\n        if (!force && isMeta) { errors.set(undefined, \"is meta\"); }\r\n        else {\r\n            this.state = \"removed\";\r\n            _records.delete(this);\r\n            afterRemove(db, current, ctx);\r\n        }\r\n        \r\n        return solids({}, {\r\n            isDone:!errors.size,\r\n            errors\r\n        });\r\n    }\r\n\r\n}", "import { solids } from \"@randajan/props\";\r\nimport { toRefId } from \"../../uni/formats\";\r\nimport { getColsPriv } from \"./Columns\";\r\nimport { ColMajor, ColMinor, PushMajor } from \"./Exceptions\";\r\n\r\n\r\n\r\n\r\nexport class Push {\r\n\r\n    constructor(_rec) {\r\n        solids(this, {\r\n            _rec\r\n        });\r\n    }\r\n\r\n    throw(error) {\r\n        if (this.isDone && error.severity !== \"minor\") { this.isDone = false; }\r\n        this.exceptions.push(error);\r\n    }\r\n\r\n    prepare(input, isUpdate=false) {\r\n        const { values, state, isMeta, isMetaColumn } = this._rec;\r\n\r\n        this.input = input;\r\n        const output = this.output = {}\r\n        const pendings = this.pendings = new Set();\r\n        this.isDone = true;\r\n        this.exceptions = [];\r\n        this.changed = new Set();\r\n\r\n        this.isPending = false;\r\n        this.isChanged = false;\r\n\r\n        if (!values._ent) { this.throw(new ColMajor(\"_ent\", \"is required\")); return; }\r\n\r\n        const _cols = getColsPriv(values._ent);\r\n        if (!_cols) { this.throw(new ColMajor(\"_ent\", \"invalid\")); return; }\r\n\r\n        for (const _col of _cols) {\r\n            const { name, formula, resetIf, noCache } = _col.values;\r\n            const real = input.hasOwnProperty(name);\r\n\r\n            output[name] = values[name]; //default output is value without change\r\n\r\n            //fail quick\r\n            if (real && state === \"ready\") {\r\n                if (_col.isMeta && isMeta && !isMetaColumn) { this.throw(new ColMinor(name, \"is meta\")); continue; }\r\n                if (formula) { this.throw(new ColMinor(name, `has formula`)); continue; }\r\n            }\r\n\r\n            if (formula && noCache) { continue; }\r\n            if (isMeta && state === \"pending\") { continue; } //meta column should never pending\r\n            if (formula) { pendings.add(_col); continue; }\r\n\r\n            if (!isUpdate || real) { pendings.add(_col); this.isPending = true; continue; }\r\n            if (resetIf) { input[name] = values[name]; pendings.add(_col); continue; } //default input \r\n        }\r\n\r\n        if (state === \"ready\" && !this.isPending) { this.throw(new PushMajor(\"blank\")); }\r\n    }\r\n\r\n    execute() {\r\n        if (this.isPending) {\r\n            for (const _col of this.pendings) { this.pull(_col); }\r\n        }\r\n\r\n        if (!this.isChanged || !this.isDone) {\r\n            this.isChanged = false;\r\n            this.output = this._rec.values;\r\n            this.changed.clear();\r\n        }\r\n\r\n        return this.output;\r\n    }\r\n\r\n    pull(_col) {\r\n        const { _rec, pendings, output, input, changed } = this;\r\n        const { values:{ name, omitChange }, traits:{ setter } } = _col;\r\n        \r\n        if (pendings.has(_col)) {\r\n\r\n            //because computed value of column can reference itself\r\n            if (this.pending === _col) { return output[name]; }\r\n            this.pending = _col;\r\n\r\n            try { setter(_rec, output, input[name], _rec.state === \"pending\");}\r\n            catch(err) { this.throw(err); }\r\n\r\n            //cleanup\r\n            delete this.pending;\r\n            pendings.delete(_col);\r\n\r\n            //detect changes\r\n            if (output[name] !== _rec.values[name]) {\r\n                changed.add(name);\r\n                if (!this.isChanged && !omitChange) { this.isChanged = true; }\r\n            }\r\n            \r\n        }\r\n\r\n        return output[name];\r\n    }\r\n\r\n    close() {\r\n        const { _rec:{current}, isDone, changed, exceptions } = this;\r\n\r\n        delete this.isDone;\r\n        delete this.input;\r\n        delete this.output;\r\n        delete this.exceptions;\r\n        delete this.pending;\r\n        delete this.pendings;\r\n        delete this.changed;\r\n        delete this.isChanged;\r\n        delete this.isPending;\r\n        \r\n\r\n        return solids({}, {\r\n            isDone,\r\n            current,\r\n            changed,\r\n            exceptions\r\n        })\r\n    }\r\n\r\n}", "import { toRefId } from \"../../uni/formats\";\r\nimport { getRecPriv } from \"./Record\";\r\nimport { meta } from \"../meta\";\r\nimport { getRecs } from \"../effects/_bits\";\r\nimport { fceNone, fcePass } from \"../../uni/consts\";\r\nimport { cacheds, solid } from \"@randajan/props\";\r\nimport { ColMajor, ColMinor } from \"./Exceptions\";\r\n\r\nconst _columnsByEnt = new Map();\r\n\r\nexport const getColsPriv = entId=>_columnsByEnt.get(entId);\r\n\r\nconst createGetter = _col=>{\r\n    const col = _col.current;\r\n    const v = _col.values;\r\n    \r\n    const { getter } = (meta._types[v.type] || col.type);\r\n    return v.type == \"ref\" ? from=>_col.db.get(v.ref, from, false) : getter;\r\n}\r\n\r\nconst createSetter = _col=>{\r\n    const col = _col.current;\r\n    const v = _col.values;\r\n\r\n    const { name, ref, parent, formula, validator, isReadonly, resetIf, init, fallback, isRequired } = col;\r\n    const { setter } = (meta._types[v.type] || col.type);\r\n\r\n    const typize = v=>v == null ? undefined : setter(v, col);\r\n    const n = v.type != \"ref\" ? typize : v=>typize(toRefId(v));\r\n\r\n    return ({current, before}, output, to, isInit)=>{\r\n        if (formula) { to = output[name] = n(formula(current, col, before)); }\r\n        else {\r\n            if (!isInit && isReadonly && isReadonly(current, col, before)) { throw new ColMinor(name, `is readonly`); }\r\n            to = output[name] = n(to);\r\n            if (validator && !validator(current[name], before[name], current, col, before)) { throw new ColMajor(name, \"is invalid\"); }\r\n\r\n            if ((isInit && to == null) || (resetIf && resetIf(current, col, before))) { \r\n                to = output[name] = !init ? undefined : n(init(current, col, before));\r\n            }\r\n        }\r\n\r\n        if (to == null && fallback) { to = output[name] = n(fallback(current, col, before)); }\r\n        if (to == null && isRequired && isRequired(current, col, before)) { throw new ColMajor(name, \"is required\"); }\r\n        return output[name];\r\n    }\r\n}\r\n\r\nconst createTraits = _col=>{\r\n    return cacheds({}, {}, {\r\n        getter:_=>createGetter(_col),\r\n        setter:_=>createSetter(_col)\r\n    });\r\n}\r\n\r\nexport const setColumn = (db, col)=>{\r\n\r\n    const _col = getRecPriv(db, col);\r\n    const ent = _col.values.ent = toRefId(_col.values.ent);\r\n\r\n    if (_columnsByEnt.has(ent)) { _columnsByEnt.get(ent).add(_col); }\r\n    else { _columnsByEnt.set(ent, new Set([_col])); }\r\n\r\n    solid(_col, \"traits\", createTraits(_col), true, true);\r\n\r\n    //this is because columns of columns that are not meta can be updated\r\n    solid(_col, \"isMetaColumn\", !meta.hasOwnProperty(ent)); \r\n\r\n    const rows = getRecs(db, ent);\r\n    if (rows) {\r\n        for (const [_, row] of rows) { getRecPriv(db, row).addColumn(_col); }\r\n    }\r\n\r\n}\r\n\r\nexport const removeColumn = (db, col)=>{\r\n    const { name, ent } = col;\r\n\r\n    const rows = getRecs(db, toRefId(ent));\r\n    if (rows) {\r\n        for (const [_, row] of rows) { getRecPriv(db, row).removeColumn(name); }\r\n    }\r\n\r\n}\r\n\r\n", "import { solid, solids } from \"@randajan/props\";\r\n\r\n\r\n\r\n\r\nclass Exception {\r\n    constructor(severity, reason, details, column) {\r\n        solids(this, { severity, column, reason, details });\r\n    }\r\n}\r\n\r\nexport class ColMinor extends Exception {\r\n    constructor(column, reason, details) {\r\n        super(\"minor\", reason, details, column);\r\n    }\r\n}\r\n\r\nexport class ColMajor extends Exception {\r\n    constructor(column, reason, details) {\r\n        super(\"major\", reason, details, column);\r\n    }\r\n}\r\n\r\nexport class PushMinor extends Exception {\r\n    constructor(reason, details) {\r\n        super(\"minor\", reason, details);\r\n    }\r\n}\r\n\r\nexport class PushMajor extends Exception {\r\n    constructor(reason, details) {\r\n        super(\"major\", reason, details);\r\n    }\r\n}", "\r\nimport { Chop } from \"./Chop\";\r\nimport { afterAdd } from \"../effects/afterAdd\";\r\nimport { afterRemove } from \"../effects/afterRemove\";\r\n\r\nimport { toRefId } from \"../../uni/formats\";\r\nimport { meta, metaEnt, metaId } from \"../meta\";\r\nimport { addOrSetRec, addRec, getRecPriv, removeRec } from \"./Record\";\r\nimport { setColumn, removeColumn } from \"./Columns\";\r\nimport { getAllRecs, getRec, getRecs } from \"../effects/_bits\";\r\nimport { solid, solids } from \"@randajan/props\";\r\n\r\nexport class DB extends Chop {\r\n\r\n    constructor(id, opt={}) {\r\n\r\n        const { init } = opt;\r\n\r\n        super(id, {\r\n            autoReset:false,\r\n            group:rec=>toRefId(rec._ent),\r\n            init:_=>{\r\n                for (const _ent in meta) {\r\n                    for (const id in meta[_ent]) {\r\n                        addRec(this, {_ent, id, isMeta:true, ...meta[_ent][id]});\r\n                    };\r\n                }\r\n                init(this);\r\n            }\r\n        });\r\n\r\n        const _cols = this.chop(\"_cols\", {\r\n            group:rec=>toRefId(rec.ent),\r\n        });\r\n\r\n        this.on((event, rec)=>{\r\n            if (event === \"reset\") {\r\n                const _recs = [];\r\n                for (const [rec] of getAllRecs(this)) {\r\n                    _recs.push(getRecPriv(this, rec).prepareInit());\r\n                }\r\n                for (const _rec of _recs) {\r\n                    const resp = _rec.init(); //init responses\r\n                    if (!resp.isDone) { console.log(resp); }\r\n                }\r\n            }\r\n        });\r\n\r\n        this.on((event, rec, ctx)=>{\r\n            const _ent = toRefId(rec?._ent);\r\n            if (_ent != \"_ents\") { return; }\r\n\r\n            const { id } = rec;\r\n    \r\n            if (event === \"remove\") {\r\n                for (const col of _cols.getList(id)) { removeRec(col, ctx, true); };\r\n            }\r\n            else if (event === \"add\") {\r\n                this.add(metaId(id, id === \"_cols\" ? r=>toRefId(r.ent) + \"-\" + r.name : undefined), ctx);\r\n                this.add(metaEnt(id), ctx);\r\n            }\r\n        });\r\n    \r\n        _cols.on((event, rec)=>{\r\n            if (event === \"add\" || event === \"update\") { setColumn(this, rec); }\r\n            else if (event === \"remove\") { removeColumn(this, rec); }\r\n        });\r\n\r\n        solids(this, {\r\n            _cols\r\n        });\r\n\r\n\r\n        this.reset();\r\n\r\n    }\r\n\r\n    isRecord(any, throwError=false) { return !!getRecPriv(this, any, throwError); }\r\n\r\n    remove(record, ctx) {\r\n        return removeRec(record, ctx);\r\n    }\r\n\r\n    add(values, ctx) {\r\n        return addRec(this, values, ctx);\r\n    }\r\n\r\n    addOrSet(values, ctx) {\r\n        return addOrSetRec(this, values, ctx);\r\n    }\r\n\r\n    addOrUpdate(values, ctx) {\r\n        return addOrSetRec(this, values, ctx, true);\r\n    }\r\n\r\n    set(record, values, ctx) {\r\n        return getRecPriv(this, record).set(values, ctx);\r\n    }\r\n\r\n    update(record, values, ctx) {\r\n        return getRecPriv(this, record).set(values, ctx, true);\r\n    }\r\n\r\n    removeBy(groupId, recId, ctx) {\r\n        const rec = this.get(groupId, recId);\r\n        if (rec) { return this.remove(rec, ctx); }\r\n    }\r\n\r\n    setBy(groupId, recId, values, ctx) {\r\n        const rec = this.get(groupId, recId);\r\n        if (rec) { return this.set(rec, values, ctx); }\r\n    }\r\n\r\n    updateBy(groupId, recId, values, ctx) {\r\n        const rec = this.get(groupId, recId);\r\n        if (rec) { return this.update(rec, values, ctx); }\r\n    }\r\n\r\n}", "import { nref, timestamps } from \"./components/uni/tools\";\r\nimport { reductor, summary } from \"./components/sync/tools\";\r\nimport { DB } from \"./components/sync/interfaces/DB\";\r\n\r\n\r\nexport default (name, stream, config={}) => new DB(name, stream, config);\r\n\r\nimport { DB as DBv3 } from \"./components/v3/index.js\";\r\n\r\nexport {\r\n    nref,\r\n    timestamps,\r\n    reductor,\r\n    summary,\r\n    DBv3\r\n}", "//import \"./fe\";\r\n\r\nimport { DBv3 } from \"../../dist/index\";\r\nimport fs from \"fs-extra\";\r\n\r\nconst records = fs.readJsonSync(\"demo/data/db.json\");\r\n\r\nconst db = new DBv3(\"db\", {\r\n    init:(self, ctx)=>{\r\n        for (const rec of records) {\r\n            self.add(rec, ctx);\r\n        }\r\n    }\r\n});\r\n\r\ndb.on((event, rec, ctx)=>{\r\n    //console.log(event, rec, ctx);\r\n});\r\n"],
  "mappings": "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",
  "names": ["jet", "_", "solid", "cached", "jet", "jet", "map", "cacheds", "solids", "solid", "selector", "solid", "virtual", "jet", "_", "list", "loader", "db", "isReadonly", "map", "jet", "_", "selector", "solid", "virtual", "cached", "solid", "virtual", "jet", "solid", "virtual", "jet", "_", "x", "Chop", "solids", "getter", "isReadonly", "isRequired", "setter", "v", "db", "solid", "DB", "id", "rec"]
}
